
// // Insertion sort is a basic sorting algorithm. Insertion sort iterates over an array, growing a sorted array behind the current location. It takes each element from the input and finds the spot, up to the current point, where that element belongs. It does this until it gets to the end of the array.

// // You've got Helpers! (click to view code)
// // Examples
// // Input	Output
// // array:
// // [ 3, 1, 2 ]	[ 1, 2, 3 ]
// // array:
// // [ 1, 0, 100, 42 ]	[ 0, 1, 42, 100 ]
// var a = {};

// var array = [3,2,1];
// ls
// function insertionSort (collection){
// 	var sortedArray = collection.splice(0);
// 	for (var i = 0; i < sortedArray.length; i++) {
// 	sortedArray[i] = ab(sortedArray[i], sortedArray[i+1]);
// 	};

// 	function ab(a,b){
// 		if (a > b || a === b){ return b};
// 		if (b > a){ return a};
// 	};

// 	};
// }

// function 2insertionSort(coll){
// 	var isSorted = false;
// 	if (isSorted === false){

// 	var tmp =
// 	if (coll[i] > coll[i+1]){

// 	}
// 	}
// }

// var object = {
// 	addMessage: function (message){
// 		var $chat = $('<div class="chat/>');
// 		var $username = $("<span class='username'/>");


// 	}
// }
	var testString = "aaabbc"
function characterFrequency (string){
	var strArray = string.split("");
	var results = [];
	var myObj = {};
	for (var i = 0; i < strArray.length; i++) {
		myObj[strArray[i]] = (myObj[strArray[i]]||0) + 1;
	};
		var i = 0;
	for(var key in myObj){
		//console.log(i, key, myObj[key]);
		results[i] = [key];
		results[i][1] = (myObj[key]);
		//console.dir(results)
		i++;
	}
	return results
}

// var recolor = function () {
// 	d3.select("rect").transition()
// 		.duration(3000)
// 			.attr("fill","hs1("
// 				 + (Math.random()*360) +",100%,50%
// 				 )").each("end", recolor);
		// }


/*
 * Basic tree that stores a value.
*/
// var Tree = function (value) {
//   this.value = value;
//   this.children = [];
// };

// Tree.prototype.map = function (callback) {
// 		var newTree = new Tree(callback(this.value));

// 	function addNewChild(oldNode){
// 		var newNode = callback(oldNode);
// 		if (newTree.isDescendant(newNode)){
// 			return
// 		}
// 		newTree.addChild(newNode);
// 		}

// 			addNewChild(oldNode);
// 		newTree.addChild(newNode);

// 		function(){
// 		for (var i = 0; i < this.children.length; i++) {
// 				callback(this.children[i])
// 			};
// 		newTree.addChild(newNode)
// 		}
// 		//needs to create a new tree with values produced by the callback
// 	}
// }
	//needs to call the call back for each node of the tree an us its value as nodes values of the new tree
  // TODO: return a new tree with the same structure as `this`,
  //       with values generated by the callback

/**
 * You shouldn't need to change anything below here,
 * but feel free to read it.
 */

/**
  * add an immediate child
  * (wrap values in Tree nodes if they're not already)
  */
// Tree.prototype.addChild = function (child) {
//   if (! child ||  ! (child instanceof Tree)){
//     child = new Tree(child);
//   }

//   if (! this.isDescendant(child)) {
//     this.children.push(child);
//   } else {
//     throw new Error("That child is already a child of this tree");
//   }
//   // return the new child node for convenience
//   return child;
// };

// /**
//   * check to see if the provided tree is already a child of this
//   * tree __or any of its sub trees__
//   */
// Tree.prototype.isDescendant = function (child) {
//   if (this.children.indexOf(child) !== -1) {
//     // `child` is an immediate child of this tree
//     return true;
//   } else {
//     for (var i = 0; i < this.children.length; i++) {
//       if(this.children[i].isDescendant(child)){
//         // `child` is descendant of this tree
//         return true;
//       }
//     }
//     return false;
//   }
// };

// /**
//   * remove an immediate child
//   */
// Tree.prototype.removeChild = function (child) {
//   var index = this.children.indexOf(child);
//   if (index !== -1) {
//     // remove the child
//     this.children.splice(index,1);
//   } else {
//     throw new Error("That node is not an immediate child of this tree");
//   }
// };



/* Largest contiguos number
//traverse through the array and compare 1 number vs next number if both are positive then sum them
cases Negative:
//if all negative then return the biggest negative number dont sume anything
//if all positive the you would return the sum all
// if mixed positive and negative:
	if number is negative and next is negative then keep the biggest

*/
var array1 = [3,4,5,6]
var array2 = [-3,5,-5]
//traverse through the array and keep the biggest number positive or negative
//traverse through the array and keep all the contiguos result numbers
//travers through the contiguos array and return the biggest contiguos number
//return the biggest value among contiguos array or the biggest number array

function conti (array){
	var biggest = 0;
	var biggestContiSum = 0;
	var tempContiSum;

	for (var i = 0; i < array.length; i++) {
		if (i === 0) {
			biggest = array[i];
			if (array[i] > 0){
				biggestContiSum = array[i];
			}
		} else  {
			if (array[i] > biggest) {
		  	  biggest = array[i];
		  	}
		  	if (array[i] < 0){
		  		results.push(biggestContiSum);
		  		biggestContiSum = 0;
		  	}
		}
		if (array[i] > 0) {
			biggestContiSum += array[i];
		}
	}
	return biggestContiSum > biggest ? biggestContiSum : biggest;
};

function numbersToEnglish (number){

	var words = {1: "one", 2: "two"}
	var unid = ["one","two", "eleven", "twelve"];
	var dec = ["eleven, twelve"];
	var cent = [];
	var magnit = ["thousand", "million","billion"];

	var string = number.toString();
	console.log(string, string.charAt(0))
	var result = "";
	for (var i = string.length - 1; i >= 0; i--) {
		result += words[string.chartAt(i)];
	};
//78193512
};

// function telephoneWords (digitString){
// 	var string = digitString.split('')*/
// 	//basecase if(result.length === digitstring.length )
// 	/*{ results.push(result) return}*/
// 	function recursive (number){

// 		var converted = [];
// 		for (var i = 0; i < possibles[numbers].length; i++) {
// 			converted.push(possibles[numbers][i])
// 			recursive(string[i])
// 			recursive()		};
// 		converted += possibles[number]
// 		return converted;

// 	}

// 	var possibles = {
// 		1:[1];
// 		2:['A','B','C'];
// 		3:[];
// 	};
// 	for (var i = 0; i < string.length; i++) {
// 		string[i]
// 	};
// 	var hashfunction = function (number) {
// 		var i;
// 		if (number === 0){ return  }

// 	}
// }
function rockPaperPermutation (roundCount) {
	var units = ['r','p','s'];
	var results = [];
	var tmp = [];
	if(roundCount){return results};
	function recursive (x){
		if(x.length === roundCount){
			results.push(x.join(''));
			return;
		}
		for (var i = 0; i < units.length; i++) {
			x.push(units[i])
			recursive(x);
			x.pop();
			}
		return;
	}
	recursive(tmp);
	return results;
};

function myRockPaperPermutation (roundCount) {
	var units = ['r','p','s'];
	var results = [];
	var tmp = [];
	for (var i = 0; i < units.length; i++) {
		tmp.push(units[i]);
		for (var i = 0; i < units.length; i++) {
			tmp.push(units[i]);
			for (var i = 0; i < units.length; i++) {
				tmp.push(units[i]);
				results.push(tmp);
				tmp.pop();
			};
			tmp.pop();
		};
		tmp.pop();
	};
	return results;
};


function telephoneWords(number){
//recursion with slice of array after each iteration
};


var bind = function(func, context){
  //Your code here
	return function(){
	var newArgs = arguments.slice(1);
  	return func.apply(context, newArgs)
    //Your code here
  }
};

Function.prototype.bind = function(context) {
  //Your code here
  return function(){
    //Your code here
  }
};

//binded ( arg1, arg2....)

// function coinSums (total) {
// 	var coins = [1,2,5,10,20,50,100,200];
// 	var combinations = 0;
// 	var solution = 0;

// 	function recursive(solution){
// 		if(solution  === total){
// 			combinations ++;
// 			//console.log(combinations);
// 			return;
// 		}
// 		for (var i = 0; i < coins.length; i++) {
// 		//debugger
// 			if (coins[i] > total){return};
			// solution += coins[i];
// 			if (solution > total){
// 				solution -= coins[i];
// 				return;
// 			};
// 			recursive(solution);
// 			//console.log(solution)
// 			//solution -= coins[i];
// 		};
// 		return
// 	};
// 	recursive(solution);
// 	return combinations;
// };


var vals = {
  I: 1,
  V: 5,
  X: 10,
  L: 50,
  C: 100,
  D: 500,
  M: 1000
};

function translateRomanNumeral (romanNumeral) {
	var accumulator = 0;
	var romans = romanNumeral.split('');
		for (var i = 0; i < romans.length; i++) {
			if(!vals[romans[i]]){return 'null'}
			if (vals[romans[i]] < vals[romans[i +1]]){
				accumulator -= vals[romans[i]];
			} else {
			if (vals[romanNumeral]){return vals[romanNumeral]}
				accumulator += vals[romans[i]];
			}
	}
	return accumulator;
};

var mixEvents = function(obj) {
  var events = {};
  obj.trigger = function (event) {
  	var args = Array.prototype.slice.call(arguments);
	  args = args.slice(1);
  	if(events[event]){
  		for (var i = 0; i < events[event].length; i++) {
  			events[event][i].apply(null, args);
  		}
  	}
  };
  obj.on = function (event, callback) {
  	events[event] === undefined ?
  		events[event] = [callback] :
  			events[event].push(callback);
  };
  return obj;
};

var makeHashTable = function(){
  var result = {};
  var storage = [];
  var storageLimit = 4;
  var size = 0;
  var resizing = false;
//***Finish This Function***//

  function resize(newSize){
    // for (var i = 0; i < storage.length; i++) {
    //    result.retrieve()
    // };
   //if 50% of the buckets hold a value then resize
      //check for how many buckets are being used and compare ro rule
      //we can hava a type of bloom filter to check how many buckets are used
   //what steps and actions does resize implies?
      //iterating over each of the value of the ht and replacing them according our new index

     //Your code here
  }

//*************************//

  result.insert = function(key, value){
    var index = getIndexBelowMaxForKey(key, storageLimit);
    storage[index] = storage[index] || [];
    var pairs = storage[index];
    var pair;
    var replaced = false;
    for (var i = 0; i < pairs.length; i++) {
      pair = pairs[i];
      if (pair[0] === key) {
        pair[1] = value;
        replaced = true;
      }
    }

    if (!replaced) {
      pairs.push([key, value]);
      size++;
    }
    if(size >= storageLimit * 0.75){
      // increase the size of the hash table
      resize(storageLimit * 2);
    }
    console.log(storage[index][0][0], storage[index][0][1]);
  };

  result.retrieve = function(key){
    var index = getIndexBelowMaxForKey(key, storageLimit);
    var pairs = storage[index];
    if (!pairs) { return; }
    var pair;

    for (var i = 0; i < pairs.length; i++) {
      pair = pairs[i];
      if (pair && pair[0] === key) {
        return pair[1];
      }
    }
  };

  result.remove = function(key){

    var index = getIndexBelowMaxForKey(key, storageLimit);
    var pairs = storage[index];
    var pair;

    for (var i = 0; i < pairs.length; i++) {
      pair = pairs[i];
      if (pair[0] === key) {
        var value = pair[1];
        delete pairs[i];
        size--;
        if(size <= storageLimit * 0.25){
          // decrease the size of the hash table
          resize(storageLimit / 2);
        }
        return value;
      }
    }
  };

  return result;
};

// This is a "hashing function". You don't need to worry about it, just use it
// to turn any string into an integer that is well-distributed between
// 0 and max - 1
var getIndexBelowMaxForKey = function(str, max){
  var hash = 0;
  for (var i = 0; i < str.length; i++) {
    hash = (hash<<5) + hash + str.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
    hash = Math.abs(hash);
  }
  return hash % max;
};

function xcoinSums (total) {
   var coins = [1,2,5,10,20,50,100,200];
   var combinations = 0;
   var reminder = total;
   var i = coins.length;
   var recursive = function (i, reminder){
      if(reminder === 0){
         combinations ++;
         return
      }
      while (reminder > 0) {
         debugger
         reminder -= coins[i];
         if(reminder < 0){
            reminder += coins[i];
         }
         recursive(--i, reminder);
      }
      return
      reminder += coins[i];
   };
   recursive(i, reminder);
   return combinations;
};

var hasCycle = function(linkedList){
var result = false;
var history = [];
var node = linkedList;
var child = node.next;
var recursive = function (node){
    if (history.indexOf(node) ==! -1 ){return true};
    if (node[value] === null){return result};
    if (node.next[value] === null){return result};
    history.push(node);
}
recursive(node.next);
  //Your beautiful code here
};

function allAnagrams (string) {
  var array = string.split('');
  var results = [];
  var tmp = [];

  var putDifLetter = function (){
    if(tmp.length === 3){
      results.push(tmp.join(''));
      return
    }
    for (var i = 0; i < array.length; i++) {
      debugger
      if(tmp.indexOf(array[i]) === -1){
      tmp.push(array[i]);
      console.log('indexOfworks')
      }
      console.log(results, tmp);
      putDifLetter();
      tmp.pop();
    };
    return
  }
  putDifLetter()
  // Write your code here, and
  return results;
}


var pal = 'dad';

var longestPalindrome = function (string) {
  var letters = string.split();
  var palindrome = [];
  var results = {};
  var anchorIndex = 1
  var check = function (anchorIndex){
   if(anchorIndex === letters.length - 1){ return }
   for (var i = 1; i < letters.length - 1; i++) {
      var next = letters[i-1];
      var last = letters [i+1];
      var anchor = letters[anchorIndex];
      palindrome.push(anchor);
      if( last === next ){
        palindrome.unshift(last);
        palindrome.push(next);

      }
    };
    anchorIndex++
    check(anchorIndex);
  }
};

function spiralTraversal (matrix) {
  var xlimit = matrix[0].length
  var ylimit = matrix.length
  var worm = [];
  var x = 0;
  var y = 0;

  var wormificator = function(sI, dI, isInvert){
    while (dI)
   results.push(matrix[sI][dI])
   if (isInvert){
    dI--;
   }
  }
  // Write your code here, and
  // return your final answer.
}

var printArray = function(array) {
  var recursive = function(array){
    console.log(array[0]);
    if (!(array.slice(1)[0] === undefined)){
    recursive(array.slice(1));
    };
  }
  recursive(array);
};

var eachy = function(input, callback){
  if(Array.isArray(input) || typeof(input) === 'string'){
    for (var i = 0; i < input.length; i++) {
      callback(input[i], i, input);
    }
  } else if (typeof(input) === 'object'){
      for(key in input){
      callback(input[i], i, input);
      }
    }
  };

var filter = function(collection, truthTest){
  var results = [];
  eachy(collection, function(elem, i, collection){
    if(truthTest(elem)){
      results.push(elem);
    }
  });
  return results;
};


// `filter` should accept a collection and a truth test. It should return an array
// containing only those elements from the collection that pass the truth test.
// It should call `each` (keep it DRY!).

// EXAMPLE:
var isString = function(input){
  return typeof input === 'string';
};
// var a = ['4',2,'marco',4,true,[1,2],{'yakko':'wakko'},6,'polo',8];
// filter(a,isString);
// yields:
// ['4','marco','polo'];

var countAnswers =  {
  count : function (start, end) {
    var init = start;
    var results = [];
    var recursive = function(){
      if (start !== init){ results.push(start);}
      console.log(results);
      if(start === end){return results;}
      countAnswers.timer = setTimeout(function(){start++; recursive();},100);
      console.log(countAnswers);
    };
    recursive();
  },
  cancel : function (){
    console.log(this.timer);
    return clearTimeout(this.timer);
  }
};

function firstNonRepeatedCharacter (string) {
  var letters = string.split('');
  var uniqs = {};
  for (var i = 0; i < letters.length; i++) {
    if ( letters[i] in uniqs ) {
      uniqs[letters[i]] = false;
    } else {
     uniqs[letters[i]] = true;
    }
  };
  console.dir(uniqs);
  for (var i = 0; i < letters.length; i++) {
    if ( uniqs[letters[i]] === true )  {
      return letters[i];
    }
  }
}


var arr1 = [1,2,3,4];
var arr2 = [2,3];

Array.prototype.isSubsetOf = function(mains) {
  var mainsObj = {}, subsetObj = {}, result = true;
  for (var i = 0; i < mains.length; i++) {
    mainsObj[mains[i]] = mains[i];
  };
  for (var i = 0; i < this.length; i++) {
    subsetObj[this[i]] = this[i];
  };
  for (var key in subsetObj) {
    if (!mainsObj[subsetObj[key]]){
      result = false;
    }
  }
  return result;
};



nthFibonacci = function(n) {
  var chain = [];
  for (var i = 0; i <= n; i++) {
    if (chain.length > 1) {
    debugger
      chain.push(chain[ i - 1 ] + chain[ i - 2 ]);
    } else if (chain.length === 0) { chain.push(0);
      } else if (chain.length === 1) { chain.push(1); }
  }
  return chain[n-1];
};

function characterFrequency (string){
  var counters = {};
  var results = [];
  var abc = 'abcdefghijklmnopqrstuvwxyz';
  for (var i = 0; i < string.length; i++) {
    if (!counters[string[i]]) { counters[string[i]] = 0 }
    counters[string[i]] = ++counters[string[i]];
  };
  for (var key in counters) {
    var pair = [key + ':', counters[key]];
    results.push(pair);
  }
  console.dir (results);
  results.sort( function(a, b) { return b[1] - a[1] });
  for (var i = 0; i < results.length; i++) {

  }
};

var bubbleSort = function(array) {
  var index = 0;
  var limit = array.length;
  var repeat = false;
  var sort = function (){
    while(index < limit) {
      if(array[index] > array[index + 1]){
        var tmp = array[index];
        array[index] = array[index + 1];
        array[index + 1] = tmp;
        repeat = true;
      }
      index ++;
    }
    if (repeat){
      sort();
    }
    repeat = false;
  }
  sort();
  return array
};


var Tree = function(value){
  this.value = value;
  this.children = [];
};

Tree.prototype.DFSelect = function(filter) {
  var results = [];


  var recursive = function (node, depth){

    if (filter(node.value, depth)) {
      results.push(node.value);
    }

    for (var i = 0; i < node.children.length; i++) {
      recursive(node.children[i], depth + 1);
    };
  };

  recursive (this, 0);
  return results;
};

Tree.prototype.addChild = function(child){
  if (!child || !(child instanceof Tree)){
    child = new Tree(child);
  }
  if(!this.isDescendant(child)){
    this.children.push(child);
  }else {
    throw new Error("That child is already a child of this tree");
  }
  // return the new child node for convenience
  return child;
};

Tree.prototype.isDescendant = function(child){
  if(this.children.indexOf(child) !== -1){
    // `child` is an immediate child of this tree
    return true;
  }else{
    for(var i = 0; i < this.children.length; i++){
      if(this.children[i].isDescendant(child)){
        // `child` is descendant of this tree
        return true;
      }
    }
    return false;
  }
};

Tree.prototype.removeChild = function(child){
  var index = this.children.indexOf(child);
  if(index !== -1){
    // remove the child
    this.children.splice(index,1);
  }else{
    throw new Error("That node is not an immediate child of this tree");
  }
};


deepEquals = function(a, b){
  var result = false;
  function subroutine(a,b) {
    if ( Object.keys(b).sort() !== Object.keys(a).sort() ) { return result}
    debugger
    for (var key in a){
      debugger
      if (b.var !== a.var) {
        debugger
        return result;
      }
      if(typeof b.var === 'object') {
        subroutine(b.var, a.var);
      }
    }
  };

  subroutine(a,b);
  return true;
};


var count = 0;
for (var i = 0; i < count; i++) {
}
//this code should console: before, after. Not during since
//the loop never runs.

// Using a for loop, write a function that:
// Takes as its only argument an array of numbers (values)
// Returns the sum of all the values in the array, excluding the first two and last two values in the array
// Returns 0 if the array contains 4 or fewer values

var forloop = function (array){
  var accumulator = 0;
  for(var i = 2; i < array.length - 2; i++){
    accumulator += array[i];
  }
  return accumulator;
};

// Write a new function for the previous problem using _.each

var eachloop = function (array){
    var accumulator = 0;
  _.each(array, function(elem, i, collection){
    if( i > 1 && i < collection.length -2 ){
    accumulator += elem;
    }
  })
  return accumulator;
};

var reduceloop = function(array){
  return _.reduce(array, function(memo, value, index, list){
    if (index > 1 && index < list.length -2){
     return memo += value;
    }
  }, 0);
};

// Using _.reduce, write a function that:
// Takes as its input an array of integers (whole numbers)
// Returns an array containing two values where:
// The first value is the count of all the even numbers in the original input array
// The second value is the count of all the odd numbers in the original input array
// Your function should only call _.reduce once

var  doubleReduce = function(array){
  var accumulator = function(sum, value){
    if( 0 === value % 2){
      sum[0] += 1;
    } else {
      sum[1] += 1;
    }
    return sum;
  };
  return _.reduce(array, accumulator, [0,0]);
};

//Explain whether this is a good or bad way to check if an argument was passed to a function and why:

var fn = function(foobar) {
  if (!foobar) {   // <- is this good or bad?
    console.log("wasn't passed foobar");
  }
};

// 'This wouldnt work in the following edge case:
//   foobar is a falsey value, the bolean false,
//   0, "", null and NAN. I had to google javascript falsy values for this.'


// Look at the following code and explain the difference between what's assigned to the variable “foo” and what's assigned to the variable “bar”:
var fn = function() {
  console.log('hello world');
};
//this value of fo after the assigment is a function type object
// var foo = fn;
// ..............is the result of fn, in this case undefined since fn doesnt return anything
// var bar = fn();

// Explain clearly what this does, why it works, and when you might use it:
// Slice returns a brand new array. I would use this when you want to convert an array like object into a real 100% array
// the arguments of a function are an array like object, thats why this is so comun... Because arguments is not an array it doesnt
// have access to the slice array method inherently.
//var args = Array.prototype.slice.call(arguments);

// Write a function called "plusOne" that:
// Takes as its only argument another function – we can call that argument "origFn"
// Assume that any function that might be passed to plusOne as origFn takes some arguments and returns a number
// Returns a new function such that:
// When the new function is called some arguments, it returns whatever number origFn would return for those same arguments, plus 1
// For example, if origFn(7,2,-13) returned 42, the new function, when called with the same arguments would return 43.

var plusOne = function(func) {
  var newFunc = function(){
    return (func.apply(arguments) + 1) ;
  };
  return newFunc;
};

//not solved yet
// Write a function to solve the following problem:
// A robot can move (step) in 4 directions: north, west, south, and east (N,W,S,E)
// Use recursion to output all permutations of directions the robot can make in 3 moves
// As an example of the expected output for 2 moves, the robot can go:
// NN, NW, NS, NE, WN, WW, WS, WE, SN, SW, SS, SE, EN, EW, ES, EE
// The expected output for 3 moves would start something like this:
// NNN, NNW, NNS, ….


var robotCompass = function(n) {
  var options = ['N', 'S', 'W', 'E'];
  var permutations = [];
  var current = [];

  var subroutine = function(step) {
    if(step === n) {
      permutations.push(current.join(''))
      return
    }
    for (var i = 0; i < options.length; i++) {
      current.push(options[i]);
      subroutine( step + 1 );
    };
  };
  subroutine(0);
  return permutations
};

var opt1robotCompass = function(n) {
  var options = ['N', 'S', 'W', 'E'];
  var permutations = [];

  var subroutine = function(step, current) {
    if(step === n) {
      permutations.push(current);
      return
    }
    for (var i = 0; i < options.length; i++) {
      subroutine( step + 1, current + options[i] );
    };
  };
  subroutine(0, '' );
  return permutations
};

var opt2robotCompass = function(n) {
  var options = ['N', 'S', 'W', 'E'];
  var permutations = [];

  var subroutine = function(step, current) {
    if(current.length === n) {
      permutations.push(current.join(''))
      return
    }
    for (var i = 0; i < options.length; i++) {
      subroutine( step + 1, current.slice().push(options[i]));
    };
  };
  subroutine(0, [] );
  return permutations
};


// Look at the following code and make sure you understand why it logs “this === window”:

var obj = {
  logIt: function() {
    if (this === obj) {
      console.log('this === obj');
    } else if (this === window) {
      console.log('this === window');
    } else {
      console.log('this === ???');
    }
  }
};

var fn = obj.logIt;

// fn(); //console logs window cause it is a free function invocation

// to be solved: tryed to methods: using prototype .bind and manual bind...
// Look at the following code (similar to above) and without changing obj, refactor what's passed to setTImeout so that, when executed, the code logs “this === obj”:

var obj = {
  logIt: function() {
    if (this === obj) {
      console.log('this === obj');
    } else if (this === window) {
      console.log('this === window');
    } else {
      // console.log('this === ???');
    }
  }
};

var fn = obj.logIt;
// setTimeout(fn, 100);
var binded = fn.bind(obj, obj);
// setTimeout(fn, 100);
// setTimeout(binded, 100);


var i = 123;
var fn = function() {
  // console.log(i);
};
i = 7
setTimeout(fn, 1000);
i = 42;
setTimeout(fn, 1000);

//settimeout call are asincronus, so they are send to the asyinc stack
//and call after the machine finished interpreting syncronus calls...

// Figure out what this code logs and explain why:

var n = 6;
var fn = function(value) {
  value++;
};
  // fn(n);
  // console.log(n);

//it will print 6 because primitives are pass as copys to functions

// Figure out what this code logs and explain why:

var a = [6];
var fn = function(array) {
  array[0]++;
};
// fn(a);
// console.log(a);

//it will print [6]...//wrong it prints [7]!! The reason for this being
//that array are passed as references into functions, so the original array is
//modified withing the function and when array[0] is evaluated, even when it
//returns a primitive stills holds a reference to de original array. Interesting

//

// Figure out what this code does and explain why:

var fn = function() {
  console.log('hi');
};
var wow = fn;
fn = undefined;
// wow();
// fn();

//my guess is that wow () it console.log hi because I guess functions are copied not pass as
//references...Right! ..fn gives an error: undefines is not a fucntion

// Do the following:
// Write a function that, given a string, outputs a separate count for each (English language) vowel in the string ('a', 'e', 'i', 'o', 'u' – ignore 'y') – consider upper and lower case letters to be the same
// Write another function that, given a string, outputs a separate count for each (English language) consonant in the string (all the letters except 'a', 'e', 'i', 'o', 'u' – no spaces or punctuation) – consider upper and lower case letters to be the same

// Do the following:
// Write a function that, given a string, outputs a separate count for each (English language) vowel in the string ('a', 'e', 'i', 'o', 'u' – ignore 'y') – consider upper and lower case letters to be the same
// Write another function that, given a string, outputs a separate count for each (English language) consonant in the string (all the letters except 'a', 'e', 'i', 'o', 'u' – no spaces or punctuation) – consider upper and lower case letters to be the same

var letterCounter = function(string) {
  var vowels = {
    a: 'a',
    e: 'e',
    i: 'i',
    o: 'o',
    u: 'u'
  };

  var counters = {};
  counters.vowels = 0;
  counters.consonants = 0;

    for (var i = 0; i < string.length; i++) {
      if( vowels[string[i]] || vowels[string[i].toLowerCase()] ){
        counters.vowels++;
      } else {
        counters.consonants++
      }
    };

  return counters;
};

// Look at the following code (similar to above) and without changing obj, refactor what's passed to setTImeout so that, when executed, the code logs “this === obj”:

var obj = {
  logIt: function() {
    if (this === obj) {
      // console.log('this === obj');
    } else if (this === window) {
      console.log('this === window');
    } else {
      console.log('this === ???');
    }
  }
};

var fn = obj.logIt;

var newFn = function() {
  obj.logIt();
}

setTimeout(newFn, 100);


function rotateMatrix (matrix) {
  var newMatrix = [];
  var rowLimit = matrix.length-1;
  var colLimit = matrix[0].length-1;
  var rowIndex = rowLimit;
  var colIndex = colLimit;

  while (colIndex >= 0){
    newMatrix.push(matrix[rowIndex][colIndex]);

  }
  // Write your code here, and
  // return your final answer.
  return newMatrix;
}

// var asyncMap = function(tasks, callback){
//   var results = [];
//     tasks.each(function(item, index, collection){
//      results[index] = item();
//   });//Your code here
//   return results;
// };

// var tasks = [ function(callback){
//               var tmp;
//               setTimeout(function(){return callback(1);}, 100)
//               return tmp;
//               },
//               function(callback){
//               setTimeout(function(){return callback(2);}, 200);}
//             ];

// var callb = function(item, index, collection){return item * item;};

// var resAsync = asyncMap(tasks, callb);

function isBalanced (string) {
  var stack = [];
  for (var i = 0; i < string.length; i++) {
    if ( string[i] === '(') {
      stack.push(string[i]);
    } else if ( string[i] === ')' && stack.length === 0 ) {
      return false;
    } else if ( string[i] === ')') {
      stack.pop();
    }
  }
  if (stack.length === 0) {
    return true;
  } else {
    return false;
  }
};
//rapid ending condition
//loop over the string
  //implement stack with all ( and pop ( every time we meet a )
  // befor poping check there are open parens to pop if not then
  //return false and finish early



































